\chapter{Desarrollo del proyecto}
\label{chap:desarrollo}

\drop{E}{n} este capítulo se describe el proceso de desarrollo de nuestro sistema de navegación por
satélite. Se empieza enumerando los requisitos originales del sistema y se explica cómo se
realizarán las pruebas. Más tarde se explica iteración a iteración las decisiones tomadas, los
prototipos desarrollados y las pruebas realizadas sobre ellos.

\section{Especificación de requisitos}

Como se comentó anteriormente (ver sección~\ref{sec:metodologia}) los requisitos del sistema se
han ido detallando a lo largo del desarrollo del proyecto ya que, originalmente, sólo teníamos una
idea muy general del sistema a desarrollar. A continuación se muestran estos requisitos generales
sobre los que partimos:

\begin{itemize}
  \item El sistema debe poder guiar a peatones, ciclistas y motoristas.
  \item El sistema debe desplegarse sobre alguna plataforma de \emph{smartphone}.
  \item El sistema debe ser compatible con la mayoría de versiones de la plataforma.
  \item La interacción con el sistema debe desarrollarse de forma implícita y ser válida para
    peatones, ciclistas y motoristas.
  \item En caso de necesitar complementos para la interacción, deben estar disponibles en el
    mercado.
  \item El sistema debe implementar las características básicas del resto de aplicaciones del
    mercado como mostrar la posición en el mapa, rotar el mapa en función de nuestra orientación o
    visualizar la ruta que se va a seguir.
\end{itemize}

\section{Pruebas}

Para describir las pruebas realizadas sobre los diferentes prototipos en este documento se ha
utilizado el patrón «Given-When-Then». Este patrón divide el proceso en 3 etapas:

\begin{itemize}
  \item \textbf{Given} (Dado): Condiciones previas sobre las que se producen los eventos.
  \item \textbf{When} (Cuando): Operaciones específicas que se producen.
  \item \textbf{Then} (Entonces): Resultados esperados.
\end{itemize}

\section{Proceso de desarrollo}

A continuación se indican las iteraciones realizadas durante el desarrollo del \acs{TFG} detallando
los objetivos, el diseño, la implementación y las pruebas de cada una de ellas.

\subsection{Iteración 1: Mostrar mapa}

En la primera iteración nos marcamos como objetivo mostrar una posición cualquiera en el mapa por
medio de una aplicación de \emph{smartphone}.

\subsubsection{Diseño}

Para realizar esta primera aproximación tendremos que tomar tres importantes decisiones de diseño:

\begin{itemize}
  \item Elegir la plataforma de \emph{smartphone} sobre la que desplegar nuestra aplicación.
  \item Elegir el proveedor de mapas que nos proporcionará las imágenes a mostrar.
  \item Elegir la versión objetivo de la plataforma de desarrollo.
\end{itemize}

En primer lugar, tras revisar las diferentes plataformas disponibles para \emph{smartphone} (ver
sección~\ref{sec:plataformas}) se estipuló que la mejor alternativa es Android. Por un lado, Android
posee de la mayor cuota de mercado (81\%) y dispone de una gran variedad de dispositivos en una
amplia gama de precios. Por otro lado, Android es un \acs{SO} que se integra fácilmente con la
plataforma de complementos Android Wear (ver sección~\ref{sec:wearables}) que es la única que nos
permite manipular el vibrador del \emph{wearable} a voluntad.

En segundo lugar, entre los proveedores de mapas existentes (ver sección~\ref{sec:proveedores}) se
seleccionó Open Street Map. Se consideró la mejor elección porque nos provee de mapas de gran
calidad completamente gratuitos. Además, si encontrásemos cualquier tipo de error en los mapas
suministrados, podríamos corregirlo porque es un proyecto colaborativo. Para simplificar el uso de
\acs{OSM} se utilizó la librería \emph{Osmdroid} tal y como se dijo en la
sección~\ref{sec:herramientasSoftware}.

En tercer y último lugar, se seleccionó como objetivo del desarrollo la \acs{API} de Android 21,
también conocida como Android 5.0 \emph{Lollipop}, por ser la más nueva y poseer el mayor número de
funcionalidades. De todos modos, se aseguró la compatibilidad desde la \acs{API} de Android 8,
también llamada Android 2.2 \emph{Froyo}, por medio de la librería \emph{Android support} para
asegurarnos de tener compatibilidad con la mayoría de dispositivos Android.

\subsubsection{Implementación}

Para visualizar los mapas de \acs{OSM} con la ayuda de la librería \emph{Osmdroid} basta con añadir
una vista del tipo \texttt{org.osmdroid.views.MapView} al \texttt{layout} de nuestra aplicación (ver
listado~\ref{code:layoutMapView}) y seleccionar el punto del mapa que deseamos centrar en la
pantalla (ver listado~\ref{code:activityMapView}) por medio de sus coordenadas geográficas.

\begin{listing}[
  float=ht,
  language = xml,
  caption  = {Ejemplo de \texttt{layout} usando \texttt{org.osmdroid.views.MapView}},
  label    = code:layoutMapView]
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        android:orientation="vertical" 
        android:layout_width="fill_parent"
        android:layout_height="fill_parent">
        
        <org.osmdroid.views.MapView android:id="@+id/map"
                android:layout_width="fill_parent" 
                android:layout_height="fill_parent" />
                
</LinearLayout>
\end{listing}

\begin{listing}[
  float=ht,
  language = java,
  caption  = {Ejemplo de \texttt{activity} mostrando un punto de un mapa en específico},
  label    = code:activityMapView]
public class MainActivity extends Activity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        MapView map = (MapView)findViewById(R.id.map);
        map.setMultiTouchControls(true);
        map.getController().setZoom(18);

        GeoPoint startPoint = new GeoPoint(39.40540171, -3.12204771);
        map.getController().setCenter(startPoint);
    }
}
\end{listing}

Por muy sencillo que pueda parecer, durante la implementación detectamos un problema: el mapa no se
centraba en la posición seleccionada. Dejaba dicha posición en la esquina superior izquierda y no en
el centro de la pantalla. Estudiando el problema descubrimos que se trataba de un \emph{bug}
documentado~\footnote{https://github.com/osmdroid/osmdroid/issues/22\#issuecomment-43092313} de
\emph{Osmdroid} y que se resolvería en la próxima versión de la librería.

Para paliar dicho problema, y siguiendo con las instrucciones detalladas en el \emph{bug},
procedimos a implementar un método que lo resolviera (ver listado~\ref{code:centerMap}).

\begin{listing}[
  float=ht,
  language = java,
  caption  = {Método utilizado para centrar el mapa en cualquier posición},
  label    = code:centerMap]
private void centerMap(final GeoPoint loc) {
    mMap.getViewTreeObserver().addOnGlobalLayoutListener(
            new ViewTreeObserver.OnGlobalLayoutListener() {
        @Override
        public void onGlobalLayout() {
            mMap.getViewTreeObserver().removeGlobalOnLayoutListener(this);
            mMap.getController().setCenter(loc);
        }
    });
}
\end{listing}

\subsubsection{Pruebas}

Al finalizar la implementación del primer prototipo se realizó la siguiente prueba:

\begin{itemize}
  \item Para determinar la correcta carga de los mapas en diferentes localizaciones

  \begin{tabular}{p{.15\textwidth}p{.75\textwidth}}
    \hline
    \textbf{Dado}     & Diferentes coordenadas geográficas \\
                      & Diferentes dispositivos con distintas versiones de Android (ver
                        sección~\ref{sec:herramientasHardware}) \\
    \textbf{Cuando}   & Ejecutamos la aplicación \\
    \textbf{Entonces} & Se muestra dicha ubicación centrada en un mapa \\
    \hline
  \end{tabular}
\end{itemize}

\subsection{Iteración 2: Mostrar posición actual en el mapa}

Una vez evaluado el prototipo de la iteración 1, se procedió a añadir una nueva funcionalidad:
mostrar la posición actual en la aplicación.

\subsubsection{Diseño}

Para poder mostrar la ubicación actual, es necesario primero conocerla. Para ello, analizamos en la
sección~\ref{sec:tecnologiasActuales} los diferentes sistemas con los que podemos obtener nuestras
coordenadas geográficas en la actualidad. Puesto que \acs{GLONASS} no estuvo operativo para uso
civil hasta 2012 no todos los \emph{smartphones} disponen en la actualidad de esta tecnología y nos
deja con una única opción razonable: \acs{NAVSTAR-GPS}.

\subsubsection{Implementación}

Para hacer uso del \acs{GPS} de nuestro \emph{smartphone} en Android sólo es necesario definir un
\texttt{LocationListener} e indicar por medio de un \texttt{LocationManager} qué clase lo implementa
y cada cuanto tiempo queremos que se ejecute (ver listado~\ref{code:locationManager}).

\begin{listing}[
  float=ht,
  language = java,
  caption  = {Ejemplo de uso de \texttt{LocationManager} utilizando la propia clase como
                 \texttt{LocationListener} y 1 segundo de intervalo entre actualizaciones},
  label    = code:locationManager]
if (mLocationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) {
    mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 1000, 1, this);
}
\end{listing}

Para que una clase implemente un \texttt{LocationListener} debe contener cuatro funciones:

\begin{itemize}
  \item \textbf{\texttt{onLocationChanged}} Para indicar qué hacer cuando nuestra ubicación cambia.
  \item \textbf{\texttt{onProviderDisabled}} Para indicar qué hacer cuando se desactiva el
    \acs{GPS}.
  \item \textbf{\texttt{onProviderEnabled}} Para indicar qué hacer cuando se activa el \acs{GPS}.
  \item \textbf{\texttt{onStatusChanged}} Para indicar qué hacer cuando cambia el estado del
    proveedor del servicio \acs{GPS}. Los posibles estados son \emph{fuera de servicio},
    \emph{temporalmente no disponible} y \emph{disponible}.
\end{itemize}

Resulta obvio que sólo necesitamos rellenar el método \texttt{onLocationChanged} con el código
necesario para mostrar una señal en el mapa (ver listado~\ref{code:onLocationChanged}). Para
simplificar la forma de dibujar nuestra posición en el mapa y mostrar el error cometido por la
trilateración (ver sección~\ref{fig:trilateracion}) de forma visual, se ha escrito una clase llamada
\texttt{LocationOverlay} en base a la clase contenida en \emph{Osmbonuspack} (ver
sección~\ref{sec:herramientasSoftware}) con el mismo nombre. Lo único verdaderamente significativo
que diferencia ambas clases es el icono utilizado para especificar nuestra posición en el mapa.

\begin{listing}[
  float=ht,
  language = java,
  caption  = {Ejemplo de implementación de \texttt{LocationListener} utilizando para mostrar la
                localización un \texttt{LocationOverlay}},
  label    = code:onLocationChanged]
public void onLocationChanged(Location loc) {
    GeoPoint myLocation = new GeoPoint(loc); 	
    
    if (!mLocationOverlay.isEnabled()) {
        mLocationOverlay.setEnabled(true);
    }
    mLocationOverlay.setLocation(myLocation);
    mLocationOverlay.setAccuracy((int)loc.getAccuracy());

    centerMap(myLocation);
}
\end{listing}

\subsubsection{Pruebas}

Al finalizar la implementación del segundo prototipo se realizó la siguiente prueba:

\begin{itemize}
  \item Para determinar la correcta carga de los mapas en diferentes localizaciones

  \begin{tabular}{p{.15\textwidth}p{.75\textwidth}}
    \hline
    \textbf{Dado}     & Diferentes localizaciones geográficas \\
                      & Diferentes dispositivos con distintas versiones de Android (ver
                        sección~\ref{sec:herramientasHardware}) \\
    \textbf{Cuando}   & Ejecutamos la aplicación \\
    \textbf{Entonces} & Se muestra dicha ubicación centrada en un mapa \\
    \hline
  \end{tabular}
\end{itemize}

\subsection{Iteración 3: Orientar mapa}

Una vez evaluado el prototipo de la iteración 2 se introdujo una nueva funcionalidad: rotar el mapa
en función de nuestra orientación. Si por ejemplo caminamos por una calle recta en dirección Oeste,
en la pantalla se vería una recta vertical. De igual manera, si por ejemplo caminamos por una calle
en dirección Sur y giramos hacia el Este, en la pantalla se vería un giro a la izquierda.

\subsubsection{Diseño}

Para poder rotar el mapa en función de nuestra orientación es necesario conocer dónde se encuentran
cualquiera de los puntos cardinales: Norte, Sur, Este u Oeste.

Prácticamente todos los \emph{smartphones} actuales disponen de un componente llamado \emph{sensor
  de orientación} que nos permite determinar la orientación espacial del teléfono por medio de tres
valores expresados en grados:

\begin{itemize}
  \item \textbf{Roll} Mide la inclinación del móvil en ralación a los laterales. Desde -90º con el
    lateral izquierdo levantado, hasta 90º con el lateral derecho levantado.
  \item \textbf{Pitch} Mide la inclinación del móvil en relación a la parte anterior y
    posterior. Desde -90º que corresponde a la posición vertical, hasta los 90º que corresponde con
    la parte anterior del móvil, pasando por 0º cuando el teléfono se encuentra a nivel.
  \item \textbf{Azimuth} Mide el punto cardinal Norte en sentido horario de 0º a 360º
\end{itemize}

\subsubsection{Implementación}

Para hacer uso del sensor de orientación de nuestro \emph{smartphone} Android basta con registrar el
uso del \texttt{Sensor} de orientación por medio de un \texttt{SensorManager} (ver
listado~\ref{code:orientacion}) indicando que clase implementa los métodos necesarios para manejar
el sensor de orientación. En este caso la propia (\texttt{this}).

\begin{listing}[
  float=ht,
  language = java,
  caption  = {Ejemplo de registro de un \texttt{Sensor} de orientación con \texttt{SensorManager}},
  label    = code:orientacion]
mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
mOrientation = mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION);
mSensorManager.registerListener(this, mOrientation, SensorManager.SENSOR_DELAY_NORMAL);
\end{listing}

El sensor de orientación en Android obliga a implementar en una clase dos métodos:

\begin{itemize}
  \item \textbf{\texttt{onSensorChanged}} Para definir qué hacer cuando cambie algún valor en el
    sensor. En el caso del sensor de orientación, proporcionará dichos valores en un \texttt{array}
    con tres posiciones:
    \begin{itemize}
      \item \textbf{Posición 0} Para los grados \texttt{azimuth}.
      \item \textbf{Posición 1} Para los grados \texttt{pitch}.
      \item \textbf{Posición 2} Para los grados \texttt{roll}.
    \end{itemize}
  \item \textbf{\texttt{onAccuracyChanged}} Para definir qué hacer cuando cambien la precisión del
    sensor.
\end{itemize}

Para implementar nuestra rotación de mapa bastó con implementar el método \texttt{onSensorChanged} y
pasar al mapa dicha rotación (ver listado~\ref{code:accuracyChanged}).

\begin{listing}[
  float=ht,
  language = java,
  caption  = {Ejemplo de rotación de mapa en función del sensor de orientación},
  label    = code:accuracyChanged]
public void onSensorChanged(SensorEvent event) {
    float azimuth = event.values[0];
    mMap.setMapOrientation(-azimuth);
}
\end{listing}

\subsubsection{Pruebas}

Al finalizar la implementación del tercer prototipo se realizaron las siguiente pruebas:

\begin{itemize}
  \item Para comprobar la correcta orientación del mapa

  \begin{tabular}{p{.15\textwidth}p{.75\textwidth}}
    \hline
    \textbf{Dado}     & Aplicación ejecutándose mientras se camina en dirección Norte \\
                      & Diferentes dispositivos con distintas versiones de Android (ver
                        sección~\ref{sec:herramientasHardware}) \\
    \textbf{Cuando}   & Se gira al Oeste o al Este \\
    \textbf{Entonces} & Se muestra un giro a la izquierda y derecha respectivamente \\
    \hline
  \end{tabular}

  \begin{tabular}{p{.15\textwidth}p{.75\textwidth}}
    \hline
    \textbf{Dado}     & Aplicación ejecutándose mientras se camina en dirección Sur \\
                      & Diferentes dispositivos con distintas versiones de Android (ver
                        sección~\ref{sec:herramientasHardware}) \\
    \textbf{Cuando}   & Se gira al Oeste o al Este \\
    \textbf{Entonces} & Se muestra un giro a la derecha e izquierda respectivamente \\
    \hline
  \end{tabular}
\end{itemize}

\subsection{Iteración 4: Crear y mostrar ruta}
\subsubsection{Diseño}
\subsubsection{Implementación}
Para peatones ciclistas y motoristas por separado.
Problemas con las rutas rectas
\begin{listing}[
  float=ht,
  language = java,
  caption  = {},
  label    = code:]

\end{listing}
\subsubsection{Pruebas}
\begin{itemize}
  \item ...

  \begin{tabular}{p{.15\textwidth}p{.75\textwidth}}
    \hline
    \textbf{Dado}     & ... \\
                      & Diferentes dispositivos con distintas versiones de Android (ver
                        sección~\ref{sec:herramientasHardware}) \\
    \textbf{Cuando}   & ... \\
    \textbf{Entonces} & ... \\
    \hline
  \end{tabular}
\end{itemize}

\subsection{Iteración 5: Navegar por ruta}
\subsubsection{Diseño}
\subsubsection{Implementación}
\begin{listing}[
  float=ht,
  language = java,
  caption  = {},
  label    = code:]

\end{listing}
\subsubsection{Pruebas}
\begin{itemize}
  \item ...

  \begin{tabular}{p{.15\textwidth}p{.75\textwidth}}
    \hline
    \textbf{Dado}     & ... \\
                      & Diferentes dispositivos con distintas versiones de Android (ver
                        sección~\ref{sec:herramientasHardware}) \\
    \textbf{Cuando}   & ... \\
    \textbf{Entonces} & ... \\
    \hline
  \end{tabular}
\end{itemize}

\subsection{Iteración 6: Selector de destino}
\subsubsection{Diseño}
\subsubsection{Implementación}
Problemas al buscar por número de casa
\begin{listing}[
  float=ht,
  language = java,
  caption  = {},
  label    = code:]

\end{listing}
\subsubsection{Pruebas}
\begin{itemize}
  \item ...

  \begin{tabular}{p{.15\textwidth}p{.75\textwidth}}
    \hline
    \textbf{Dado}     & ... \\
                      & Diferentes dispositivos con distintas versiones de Android (ver
                        sección~\ref{sec:herramientasHardware}) \\
    \textbf{Cuando}   & ... \\
    \textbf{Entonces} & ... \\
    \hline
  \end{tabular}
\end{itemize}

\subsection{Iteración 7: Avisos por pantalla}
\subsubsection{Diseño}
\subsubsection{Implementación}
\begin{listing}[
  float=ht,
  language = java,
  caption  = {},
  label    = code:]

\end{listing}
\subsubsection{Pruebas}
\begin{itemize}
  \item ...

  \begin{tabular}{p{.15\textwidth}p{.75\textwidth}}
    \hline
    \textbf{Dado}     & ... \\
                      & Diferentes dispositivos con distintas versiones de Android (ver
                        sección~\ref{sec:herramientasHardware}) \\
    \textbf{Cuando}   & ... \\
    \textbf{Entonces} & ... \\
    \hline
  \end{tabular}
\end{itemize}

\subsection{Iteración 8: Avisos sonoros}
\subsubsection{Diseño}
\subsubsection{Implementación}
Por qué no avisos grabados...
\begin{listing}[
  float=ht,
  language = java,
  caption  = {},
  label    = code:]

\end{listing}
\subsubsection{Pruebas}
\begin{itemize}
  \item ...

  \begin{tabular}{p{.15\textwidth}p{.75\textwidth}}
    \hline
    \textbf{Dado}     & ... \\
                      & Diferentes dispositivos con distintas versiones de Android (ver
                        sección~\ref{sec:herramientasHardware}) \\
    \textbf{Cuando}   & ... \\
    \textbf{Entonces} & ... \\
    \hline
  \end{tabular}
\end{itemize}

\subsection{Iteración 9: Avisos vibratorios}
\subsubsection{Diseño}
\subsubsection{Implementación}
Elección de complemento... puesto que es una barrera de entrada el smartwatch se desarrolla para
también para otros móviles.
Codificación de la vibración (rotondas y tal)
Hablar del paso de mensajes
Problemas con el paso de mensajes por agrupar pensajes
\begin{listing}[
  float=ht,
  language = java,
  caption  = {},
  label    = code:]

\end{listing}
\subsubsection{Pruebas}
\begin{itemize}
  \item ...

  \begin{tabular}{p{.15\textwidth}p{.75\textwidth}}
    \hline
    \textbf{Dado}     & ... \\
                      & Diferentes dispositivos con distintas versiones de Android (ver
                        sección~\ref{sec:herramientasHardware}) \\
    \textbf{Cuando}   & ... \\
    \textbf{Entonces} & ... \\
    \hline
  \end{tabular}
\end{itemize}

% Local Variables:
% TeX-master: "main.tex"
%  coding: utf-8
%  mode: latex
%  mode: flyspell
%  ispell-local-dictionary: "castellano8"
% End:
